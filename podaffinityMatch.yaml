#!/bin/bash

# Ustawienie minimalnych wymaga≈Ñ na pod
# Przyk≈Çad: ./znajdz_wezly.sh 0.5 512
REQUIRED_CPU_CORES=${1}
REQUIRED_MEM_MIB=${2}

# Sprawdzenie argument√≥w
if [ -z "$REQUIRED_CPU_CORES" ] || [ -z "$REQUIRED_MEM_MIB" ]; then
    echo "üö® U≈ºycie: $0 <wymagane_CPU_rdzenie> <wymagana_PAMIEC_MiB>"
    echo "Przyk≈Çad: $0 0.5 512"
    exit 1
fi

echo "--- üìã Wymagane zasoby: ---"
echo "CPU: $REQUIRED_CPU_CORES rdzeni"
echo "PAMIƒòƒÜ: $REQUIRED_MEM_MIB MiB"
echo "------------------------------"

# Nag≈Ç√≥wek tabeli
echo ""
printf "%-30s | %-15s | %-15s | %-10s\n" "NAZWA WEZ≈ÅA" "DOSTƒòPNE CPU" "DOSTƒòPNA PAMIƒòƒÜ" "STATUS"
printf "%-30s | %-15s | %-15s | %-10s\n" "------------------------------" "---------------" "---------------" "----------"

# Pobranie listy wszystkich wƒôz≈Ç√≥w i iteracja przez nie
# U≈ºywamy jq do parsowania JSON z 'oc get nodes -o json'
oc get nodes -o json | jq -r '.items[] | .metadata.name as $name | .status.allocatable as $allocatable | "\($name) \($allocatable.cpu) \($allocatable.memory)"' | while read -r NODE_NAME ALLOCATABLE_CPU ALLOCATABLE_MEM_RAW; do

    # Konwersja jednostek CPU
    # Kubernetes zwraca "m" (milicore) lub rdzenie. Konwertujemy na rdzenie zmiennoprzecinkowe.
    if [[ "$ALLOCATABLE_CPU" == *m ]]; then
        # Ma miliccores, np. 500m
        CPU_CORES_FLOAT=$(echo "scale=3; ${ALLOCATABLE_CPU%m} / 1000" | bc -l)
    else
        # Jest w rdzeniach, np. 4
        CPU_CORES_FLOAT=$(echo "scale=3; $ALLOCATABLE_CPU / 1" | bc -l)
    fi

    # Konwersja jednostek Pamiƒôci
    # Kubernetes zwraca Mi, Gi, Ki, itp. Konwertujemy na MiB (Mebibajty).
    # UWAGA: Ten prosty skrypt obs≈Çuguje tylko Mi, Gi i Ki.
    MEMORY_MIB_FLOAT=0
    UNIT=""
    MEM_VALUE=""
    
    # WyciƒÖgniƒôcie warto≈õci i jednostki (np. 4096Mi -> 4096, Mi)
    if [[ $ALLOCATABLE_MEM_RAW =~ ([0-9]+)([A-Za-z]+) ]]; then
        MEM_VALUE=${BASH_REMATCH[1]}
        UNIT=${BASH_REMATCH[2]}
    fi

    case $UNIT in
        Mi)
            MEMORY_MIB_FLOAT=$(echo "$MEM_VALUE" | bc -l)
            ;;
        Gi)
            # GiB * 1024 MiB/GiB
            MEMORY_MIB_FLOAT=$(echo "$MEM_VALUE * 1024" | bc -l)
            ;;
        Ki)
            # KiB / 1024 KiB/MiB
            MEMORY_MIB_FLOAT=$(echo "scale=3; $MEM_VALUE / 1024" | bc -l)
            ;;
        *)
            # Domy≈õlnie bierzemy jako MiB, je≈õli nieznana jednostka lub brak jednostki
            MEMORY_MIB_FLOAT=$(echo "$MEM_VALUE / 1" | bc -l)
            ;;
    esac

    # Por√≥wnanie zasob√≥w (wymaga bc - kalkulator dla liczb zmiennoprzecinkowych)
    # Sprawdzenie CPU
    CAN_RUN_CPU=$(echo "$CPU_CORES_FLOAT >= $REQUIRED_CPU_CORES" | bc)
    # Sprawdzenie Pamiƒôci
    CAN_RUN_MEM=$(echo "$MEMORY_MIB_FLOAT >= $REQUIRED_MEM_MIB" | bc)

    STATUS="‚ùå NIE"
    if [ "$CAN_RUN_CPU" -eq 1 ] && [ "$CAN_RUN_MEM" -eq 1 ]; then
        STATUS="‚úÖ TAK"
    fi

    # Wydruk wyniku
    printf "%-30s | %-15.3f | %-15.0f | %-10s\n" "$NODE_NAME" "$CPU_CORES_FLOAT" "$MEMORY_MIB_FLOAT" "$STATUS"

done

echo ""
echo "--- ‚úÖ Koniec skanowania. Powy≈ºsza tabela przedstawia wƒôz≈Çy, na kt√≥rych pod o podanych wymaganiach mo≈ºe zostaƒá umieszczony. ---"

# Wskaz√≥wka: U≈ºyj 'kubectl' zamiast 'oc', je≈õli nie jeste≈õ na Red Hat OpenShift.